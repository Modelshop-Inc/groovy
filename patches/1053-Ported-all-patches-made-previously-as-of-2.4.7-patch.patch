From 093f955d3f7d827bc828a89b57946d68d4602f57 Mon Sep 17 00:00:00 2001
From: ianhamilton <ianhamilton87@gmail.com>
Date: Mon, 24 Sep 2018 10:22:06 -0400
Subject: [PATCH 1053/1057] Ported all patches made previously as of
 2.4.7-patch6 release.

---
 .../groovy/groovy/lang/MetaClassImpl.java     |  22 +-
 .../groovy/runtime/DefaultGroovyMethods.java  |  23 +-
 .../DefaultTypeTransformation.java            |  11 +-
 .../groovy/runtime/typehandling/FastMath.java | 262 ++++++++++++++++++
 .../runtime/typehandling/NumberMath.java      |  79 +++---
 5 files changed, 344 insertions(+), 53 deletions(-)
 create mode 100644 src/main/java/org/codehaus/groovy/runtime/typehandling/FastMath.java

diff --git a/src/main/groovy/groovy/lang/MetaClassImpl.java b/src/main/groovy/groovy/lang/MetaClassImpl.java
index 4dc1d0660..5afa9bb7d 100644
--- a/src/main/groovy/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/groovy/lang/MetaClassImpl.java
@@ -1069,7 +1069,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * @see MetaClass#invokeMethod(Class, Object, String, Object[], boolean, boolean)
      */
     public Object invokeMethod(Class sender, Object object, String methodName, Object[] originalArguments, boolean isCallToSuper, boolean fromInsideClass) {
-        checkInitalised();
+        //checkInitalised();
         if (object == null) {
             throw new NullPointerException("Cannot invoke method: " + methodName + " on null object");
         }
@@ -1451,7 +1451,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
     public Object invokeStaticMethod(Object object, String methodName, Object[] arguments) {
-        checkInitalised();
+        //checkInitalised();
 
         final Class sender = object instanceof Class ? (Class) object : object.getClass();
         if (sender != theClass) {
@@ -1701,7 +1701,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * @since Groovy 2.1.0
      */
     public MetaMethod retrieveConstructor(Object[] arguments) {
-        checkInitalised();
+        //checkInitalised();
         if (arguments == null) arguments = EMPTY_ARGUMENTS;
         Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
         MetaClassHelper.unwrap(arguments);
@@ -1726,7 +1726,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
     private Object invokeConstructor(Class at, Object[] arguments) {
-        checkInitalised();
+        //checkInitalised();
         if (arguments == null) arguments = EMPTY_ARGUMENTS;
         Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
         MetaClassHelper.unwrap(arguments);
@@ -1758,7 +1758,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * properties to set
      */
     public void setProperties(Object bean, Map map) {
-        checkInitalised();
+        //checkInitalised();
         for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
             Map.Entry entry = (Map.Entry) iter.next();
             String key = entry.getKey().toString();
@@ -1782,7 +1782,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             return mc.getProperty(sender, object, name, useSuper, false);
         }
 
-        checkInitalised();
+        //checkInitalised();
 
         //----------------------------------------------------------------------
         // turn getProperty on a Map to get on the Map itself
@@ -1894,7 +1894,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             };
         }
 
-        checkInitalised();
+        //checkInitalised();
 
         //----------------------------------------------------------------------
         // turn getProperty on a Map to get on the Map itself
@@ -2118,7 +2118,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * @return a list of MetaProperty objects
      */
     public List<MetaProperty> getProperties() {
-        checkInitalised();
+        //checkInitalised();
         SingleKeyHashMap propertyMap = classPropertyIndex.getNullable(theCachedClass);
         if (propertyMap==null) {
             // GROOVY-6903: May happen in some special environment, like under Android, due
@@ -2634,7 +2634,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * @param fromInsideClass Whether the call was invoked from the inside or the outside of the class.
      */
     public void setProperty(Class sender, Object object, String name, Object newValue, boolean useSuper, boolean fromInsideClass) {
-        checkInitalised();
+        //checkInitalised();
 
         //----------------------------------------------------------------------
         // handling of static
@@ -2855,7 +2855,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * @return The attribute value
      */
     public Object getAttribute(Class sender, Object object, String attribute, boolean useSuper, boolean fromInsideClass) {
-        checkInitalised();
+        //checkInitalised();
 
         boolean isStatic = theClass != Class.class && object instanceof Class;
         if (isStatic && object != theClass) {
@@ -2896,7 +2896,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * @param fromInsideClass Whether the call was invoked from the inside or the outside of the class
      */
     public void setAttribute(Class sender, Object object, String attribute, Object newValue, boolean useSuper, boolean fromInsideClass) {
-        checkInitalised();
+        //checkInitalised();
 
         boolean isStatic = theClass != Class.class && object instanceof Class;
         if (isStatic && object != theClass) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index afd363a6c..f961be4b9 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -1144,7 +1144,12 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static boolean isCase(Collection caseValue, Object switchValue) {
-        return caseValue.contains(switchValue);
+
+        // tpt patch - need to check coerce
+        for (Object value : caseValue) {
+            if (coercedEquals(value, switchValue)) return true;
+        }
+        return false;
     }
 
     /**
@@ -6989,6 +6994,10 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         T answer = null;
         boolean first = true;
         for (T value : self) {
+
+            // tpt patch 2018-04-16
+            if (value==null) continue;
+
             if (first) {
                 first = false;
                 answer = value;
@@ -7076,6 +7085,10 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         Object answerValue = null;
         for (T item : self) {
             Object value = closure.call(item);
+
+            // tpt patch 2018-04-16
+            if (value==null) continue;
+
             if (first) {
                 first = false;
                 answer = item;
@@ -7309,6 +7322,10 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         Object answerValue = null;
         for (T item : self) {
             Object value = closure.call(item);
+
+            // tpt patch 2018-04-16
+            if (value==null) continue;
+
             if (first) {
                 first = false;
                 answer = item;
@@ -7393,6 +7410,10 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         T answer = null;
         boolean first = true;
         for (T value : self) {
+
+            // tpt patch 2018-04-16
+            if (value==null) continue;
+
             if (first) {
                 first = false;
                 answer = value;
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
index 14cbeccd5..153a10bd0 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
@@ -595,13 +595,18 @@ public class DefaultTypeTransformation {
                     if (!equalityCheckOnly) cause = cce;
                 }
             }
+            // TPT 2016-09-23 - allow naked string enum compares
+            if (left instanceof Enum || right instanceof Enum) {
+                return left.toString().compareTo(right.toString());
+            }
         }
 
+		/* TPT 2016-09-21 - comment out to cause non-compatible equality compares to throw an exception - also, remove data from error message (security)
         if (equalityCheckOnly) {
             return -1; // anything other than 0
-        }
-        String message = MessageFormat.format("Cannot compare {0} with value ''{1}'' and {2} with value ''{3}''",
-                left.getClass().getName(), left, right.getClass().getName(), right);
+        } */
+        String message = MessageFormat.format("Cannot compare {0} with {1}",
+                left.getClass().getName(), right.getClass().getName());
         if (cause != null) {
             throw new IllegalArgumentException(message, cause);
         } else {
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/FastMath.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/FastMath.java
new file mode 100644
index 000000000..37c6f37ef
--- /dev/null
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/FastMath.java
@@ -0,0 +1,262 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.runtime.typehandling;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import static java.math.MathContext.DECIMAL64;
+
+/**
+ * Created by tomto on 5/6/2017.
+ */
+public class FastMath extends NumberMath {
+
+    public static final FastMath INSTANCE = new FastMath();
+    private FastMath() {}
+
+    @Override
+    protected Number absImpl(Number number) {
+
+        if (number==null) return 0;
+
+        if (number instanceof Double) {
+            return Math.abs((Double)number);
+        } else if (number instanceof Float) {
+            return Math.abs((Float)number);
+        } else if (number instanceof Long) {
+            return Math.abs((Long)number);
+        } else if (number instanceof Integer || number instanceof Short || number instanceof Byte) {
+            return Math.abs(number.intValue());
+        } else if (number instanceof BigDecimal) {
+            return ((BigDecimal)number).abs();
+        } else if (number instanceof BigInteger) {
+            return ((BigInteger)number).abs();
+        }
+        throw new RuntimeException("Unsupported number type:" + number.getClass());
+    }
+
+    @Override
+    public Number addImpl(Number left, Number right) {
+
+        if (left==null) return right;
+        if (right==null) return left;
+
+        if (left instanceof BigDecimal || right instanceof BigDecimal) {
+            return toBigDecimalLocal(left).add(toBigDecimalLocal(right));
+        } else if (left instanceof Double || right instanceof Double) {
+            return left.doubleValue() + right.doubleValue();
+        } else if (left instanceof Float || right instanceof Float) {
+            return left.floatValue() + right.doubleValue();
+        } else if (left instanceof BigInteger || right instanceof BigInteger) {
+            return toBigIntegerLocal(left).add(toBigIntegerLocal(right));
+        } else if (left instanceof Long || right instanceof Long) {
+            if (right instanceof Long || right instanceof Integer || right instanceof Short || right instanceof Byte) {
+                return left.longValue() + right.longValue();
+            } else {
+                return left.doubleValue() + right.doubleValue();
+            }
+        } else if (left instanceof Integer || left instanceof Short || left instanceof Byte) {
+            if (right instanceof Integer || right instanceof Short || right instanceof Byte) {
+                return left.intValue() + right.intValue();
+            } else {
+                return left.doubleValue() + right.doubleValue();
+            }
+        }
+        throw new RuntimeException("Unsupported number type:" + left.getClass() + " or " + right.getClass());
+    }
+
+    @Override
+    public Number subtractImpl(Number left, Number right) {
+        if (left==null) return right;
+        if (right==null) return left;
+
+        if (left instanceof BigDecimal || right instanceof BigDecimal) {
+            return toBigDecimalLocal(left).subtract(toBigDecimalLocal(right));
+        } else if (left instanceof Double || right instanceof Double) {
+            return left.doubleValue() - right.doubleValue();
+        } else if (left instanceof Float || right instanceof Float) {
+            return left.floatValue() - right.doubleValue();
+        } else if (left instanceof BigInteger || right instanceof BigInteger) {
+            return toBigIntegerLocal(left).subtract(toBigIntegerLocal(right));
+        } else if (left instanceof Long || right instanceof Long) {
+            if (right instanceof Long || right instanceof Integer || right instanceof Short) {
+                return left.longValue() - right.longValue();
+            } else {
+                return left.doubleValue() - right.doubleValue();
+            }
+        } else if (left instanceof Integer || left instanceof Short || left instanceof Byte) {
+            if (right instanceof Integer || right instanceof Short || right instanceof Byte) {
+                return left.intValue() - right.intValue();
+            } else {
+                return left.doubleValue() - right.doubleValue();
+            }
+        }
+        throw new RuntimeException("Unsupported number type:" + left.getClass() + " or " + right.getClass());
+    }
+
+    @Override
+    public Number multiplyImpl(Number left, Number right) {
+        if (left==null || right==null) return 0;
+
+        if (left instanceof BigDecimal || right instanceof BigDecimal) {
+            return toBigDecimalLocal(left).multiply(toBigDecimalLocal(right));
+        } else if (left instanceof Double || right instanceof Double) {
+            return left.doubleValue() * right.doubleValue();
+        } else if (left instanceof Float || right instanceof Float) {
+            return left.floatValue() * right.doubleValue();
+        } else if (left instanceof BigInteger || right instanceof BigInteger) {
+            return toBigIntegerLocal(left).multiply(toBigIntegerLocal(right));
+        } else if (left instanceof Long || right instanceof Long) {
+            if (right instanceof Long || right instanceof Integer || right instanceof Short) {
+                return left.longValue() * right.longValue();
+            } else {
+                return left.doubleValue() * right.doubleValue();
+            }
+        } else if (left instanceof Integer || left instanceof Short || left instanceof Byte) {
+            if (right instanceof Integer || right instanceof Short || right instanceof Byte) {
+                return left.intValue() * right.intValue();
+            } else {
+                return left.doubleValue() * right.doubleValue();
+            }
+        }
+        throw new RuntimeException("Unsupported number type:" + left.getClass() + " or " + right.getClass());
+    }
+
+    @Override
+    public Number divideImpl(Number left, Number right) {
+
+        if (left==null) return 0;
+        if (right==null || right.doubleValue()==0.0d) {
+            throw new ArithmeticException("Divide by zero");
+        }
+
+        if (left instanceof BigDecimal || right instanceof BigDecimal) {
+            try {
+                return toBigDecimalLocal(left).divide(toBigDecimalLocal(right), DECIMAL64);
+            } catch (ArithmeticException var9) {
+                return left.doubleValue() / right.doubleValue();
+            }
+        } else if (left instanceof Double || right instanceof Double) {
+            return left.doubleValue() / right.doubleValue();
+        } else if (left instanceof Float || right instanceof Float) {
+            return left.doubleValue() / right.doubleValue();
+        } else if (left instanceof BigInteger || right instanceof BigInteger) {
+            try {
+                return toBigDecimalLocal(left).divide(toBigDecimalLocal(right), DECIMAL64);
+            } catch (ArithmeticException var9) {
+                return left.doubleValue() / right.doubleValue();
+            }
+        } else if (left instanceof Long) {
+            return left.doubleValue() / right.doubleValue();
+        } else if (left instanceof Integer || left instanceof Short || left instanceof Byte) {
+            return left.doubleValue() / right.doubleValue();
+        }
+        throw new RuntimeException("Unsupported number type:" + left.getClass() + " or " + right.getClass());
+    }
+
+    @Override
+    public int compareToImpl(Number left, Number right) {
+        if (left==null) left = 0;
+        if (right==null) right = 0;
+
+        if (left instanceof BigDecimal || right instanceof BigDecimal) {
+            return toBigDecimalLocal(left).compareTo(toBigDecimalLocal(right));
+        } else if (left instanceof Double || right instanceof Double) {
+            return Double.compare(left.doubleValue(), right.doubleValue());
+        } else if (left instanceof Float || right instanceof Float) {
+            return Float.compare(left.floatValue(), right.floatValue());
+        } else if (left instanceof BigInteger || right instanceof BigInteger) {
+            return toBigIntegerLocal(left).compareTo(toBigIntegerLocal(right));
+        } else if (left instanceof Long || left instanceof Integer || left instanceof Short || left instanceof Byte) {
+            if (right instanceof Long || right instanceof Integer || right instanceof Short || right instanceof Byte) {
+                return (left.longValue() < right.longValue()) ? -1 : ((left.longValue() == right.longValue()) ? 0 : 1);
+            } else {
+                return (left.doubleValue() < right.doubleValue()) ? -1 : ((left.doubleValue() == right.doubleValue()) ? 0 : 1);
+            }
+        }
+        throw new RuntimeException("Unsupported number type:" + left.getClass() + " or " + right.getClass());
+    }
+
+    @Override
+    protected Number unaryMinusImpl(Number number) {
+
+        if (number==null) return null;
+
+        if (number instanceof Double) {
+            return -((Double)number);
+        } else if (number instanceof Float) {
+            return -((Float)number);
+        } else if (number instanceof Long) {
+            return -((Long)number);
+        } else if (number instanceof Integer) {
+            return -((Integer)number);
+        } else if (number instanceof Short) {
+            return -((Short)number);
+        } else if (number instanceof Byte) {
+            return -((Byte)number);
+        } else if (number instanceof BigDecimal) {
+            return ((BigDecimal)number).negate();
+        } else if (number instanceof BigInteger) {
+            return ((BigInteger)number).negate();
+        }
+        throw new RuntimeException("Unsupported number type:" + number.getClass());
+    }
+
+    @Override
+    protected Number unaryPlusImpl(Number number) {
+        return number;
+    }
+
+    protected Number modImpl(Number left, Number right) {
+        if (left==null || right==null) return 0;
+
+        if (left instanceof BigDecimal || right instanceof BigDecimal) {
+            return new BigDecimal(left.doubleValue() % right.doubleValue(), DECIMAL64);
+        } else if (left instanceof Double || right instanceof Double) {
+            return left.doubleValue() % right.doubleValue();
+        } else if (left instanceof Float || right instanceof Float) {
+            return left.floatValue() % right.doubleValue();
+        } else if (left instanceof BigInteger || right instanceof BigInteger) {
+            return new BigDecimal(left.doubleValue() % right.doubleValue(), DECIMAL64);
+        } else if (left instanceof Long || right instanceof Long) {
+            if (right instanceof Long || right instanceof Integer || right instanceof Short || right instanceof Byte) {
+                return left.longValue() % right.longValue();
+            } else {
+                return left.doubleValue() % right.doubleValue();
+            }
+        } else if (left instanceof Integer || left instanceof Short || left instanceof Byte) {
+            if (right instanceof Integer || right instanceof Short) {
+                return left.intValue() % right.intValue();
+            } else {
+                return left.doubleValue() % right.doubleValue();
+            }
+        }
+        throw new RuntimeException("Unsupported number type:" + left.getClass() + " or " + right.getClass());
+    }
+
+    public BigDecimal toBigDecimalLocal(Number n) {
+        return (n instanceof BigDecimal ? (BigDecimal) n : new BigDecimal(n.toString(), DECIMAL64));
+    }
+
+    public BigInteger toBigIntegerLocal(Number n) {
+        return (n instanceof BigInteger ? (BigInteger) n : new BigInteger(n.toString()));
+    }
+
+}
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java
index 37fa65f4b..2c94ff738 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java
@@ -192,47 +192,50 @@ public abstract class NumberMath {
      * the result is BigDecimal
      */
     public static NumberMath getMath(Number left, Number right) {
-        // FloatingPointMath wins according to promotion Matrix
-        if (isFloatingPoint(left) || isFloatingPoint(right)) {
-            return FloatingPointMath.INSTANCE;
-        }
-        NumberMath leftMath = getMath(left);
-        NumberMath rightMath = getMath(right);
-
-        if (leftMath == BigDecimalMath.INSTANCE || rightMath == BigDecimalMath.INSTANCE) {
-            return BigDecimalMath.INSTANCE;
-        }
-        if (leftMath == BigIntegerMath.INSTANCE || rightMath == BigIntegerMath.INSTANCE) {
-            return BigIntegerMath.INSTANCE;
-        }
-        if (leftMath == LongMath.INSTANCE || rightMath == LongMath.INSTANCE) {
-            return LongMath.INSTANCE;
-        }
-        if (leftMath == IntegerMath.INSTANCE || rightMath == IntegerMath.INSTANCE) {
-            return IntegerMath.INSTANCE;
-        }
-        // also for custom Number implementations
-        return BigDecimalMath.INSTANCE;
+        return FastMath.INSTANCE;
+//        // FloatingPointMath wins according to promotion Matrix
+//        if (isFloatingPoint(left) || isFloatingPoint(right)) {
+//            return FloatingPointMath.INSTANCE;
+//        }
+//        NumberMath leftMath = getMath(left);
+//        NumberMath rightMath = getMath(right);
+//
+//        if (leftMath == BigDecimalMath.INSTANCE || rightMath == BigDecimalMath.INSTANCE) {
+//            return BigDecimalMath.INSTANCE;
+//        }
+//        if (leftMath == BigIntegerMath.INSTANCE || rightMath == BigIntegerMath.INSTANCE) {
+//            return BigIntegerMath.INSTANCE;
+//        }
+//        if (leftMath == LongMath.INSTANCE || rightMath == LongMath.INSTANCE) {
+//            return LongMath.INSTANCE;
+//        }
+//        if (leftMath == IntegerMath.INSTANCE || rightMath == IntegerMath.INSTANCE) {
+//            return IntegerMath.INSTANCE;
+//        }
+//        // also for custom Number implementations
+//        return BigDecimalMath.INSTANCE;
     }
 
     /* package private */ static NumberMath getMath(Number number) {
-        if (isLong(number)) {
-            return LongMath.INSTANCE;
-        }
-        if (isFloatingPoint(number)) {
-            return FloatingPointMath.INSTANCE;
-        }
-        if (isBigDecimal(number)) {
-            return BigDecimalMath.INSTANCE;
-        }
-        if (isBigInteger(number)) {
-            return BigIntegerMath.INSTANCE;
-        }
-        if (isInteger(number) || isShort(number) || isByte(number)) {
-            return IntegerMath.INSTANCE;
-        }
-        // also for custom Number implementations
-        return BigDecimalMath.INSTANCE;
+        return FastMath.INSTANCE;
+
+//        if (isLong(number)) {
+//            return LongMath.INSTANCE;
+//        }
+//        if (isFloatingPoint(number)) {
+//            return FloatingPointMath.INSTANCE;
+//        }
+//        if (isBigDecimal(number)) {
+//            return BigDecimalMath.INSTANCE;
+//        }
+//        if (isBigInteger(number)) {
+//            return BigIntegerMath.INSTANCE;
+//        }
+//        if (isInteger(number) || isShort(number) || isByte(number)) {
+//            return IntegerMath.INSTANCE;
+//        }
+//        // also for custom Number implementations
+//        return BigDecimalMath.INSTANCE;
     }
 
     //Subclasses implement according to the type promotion hierarchy rules
-- 
2.17.0

